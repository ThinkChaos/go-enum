// Code generated by go-enum DO NOT EDIT.
// Version: example
// Revision: example
// Build Date: example
// Built By: example

package example

import (
	"fmt"
	"strings"
)

const (
	// MakeToyota is a Make of type Toyota.
	MakeToyota Make = iota
	// Skipped value.
	_
	// MakeChevy is a Make of type Chevy.
	MakeChevy
	// Skipped value.
	_
	// MakeFord is a Make of type Ford.
	MakeFord
	// Skipped value.
	_
	// MakeTesla is a Make of type Tesla.
	MakeTesla
	// Skipped value.
	_
	// MakeHyundai is a Make of type Hyundai.
	MakeHyundai
	// Skipped value.
	_
	// MakeNissan is a Make of type Nissan.
	MakeNissan
	// Skipped value.
	_
	// MakeJaguar is a Make of type Jaguar.
	MakeJaguar
	// Skipped value.
	_
	// MakeAudi is a Make of type Audi.
	MakeAudi
	// Skipped value.
	_
	// MakeBMW is a Make of type BMW.
	MakeBMW
	// Skipped value.
	_
	// MakeMercedesBenz is a Make of type Mercedes-Benz.
	MakeMercedesBenz
	// Skipped value.
	_
	// MakeVolkswagon is a Make of type Volkswagon.
	MakeVolkswagon
)

var _makeNames = []string{
	_makeName[0:6],
	_makeName[6:11],
	_makeName[11:15],
	_makeName[15:20],
	_makeName[20:27],
	_makeName[27:33],
	_makeName[33:39],
	_makeName[39:43],
	_makeName[43:46],
	_makeName[46:59],
	_makeName[59:69],
}

// MakeNames returns a list of possible string values of Make.
func MakeNames() []string {
	tmp := make([]string, len(_makeNames))
	copy(tmp, _makeNames)
	return tmp
}

var ErrInvalidMake = fmt.Errorf("not a valid Make, try [%s]", strings.Join(_makeNames, ", "))

// MakeValues returns a list of the values for Make
func MakeValues() []Make {
	return []Make{
		MakeToyota,
		MakeChevy,
		MakeFord,
		MakeTesla,
		MakeHyundai,
		MakeNissan,
		MakeJaguar,
		MakeAudi,
		MakeBMW,
		MakeMercedesBenz,
		MakeVolkswagon,
	}
}

const _makeName = "ToyotaChevyFordTeslaHyundaiNissanJaguarAudiBMWMercedes-BenzVolkswagon"

var _makeMap = map[Make]string{
	MakeToyota:       _makeName[0:6],
	MakeChevy:        _makeName[6:11],
	MakeFord:         _makeName[11:15],
	MakeTesla:        _makeName[15:20],
	MakeHyundai:      _makeName[20:27],
	MakeNissan:       _makeName[27:33],
	MakeJaguar:       _makeName[33:39],
	MakeAudi:         _makeName[39:43],
	MakeBMW:          _makeName[43:46],
	MakeMercedesBenz: _makeName[46:59],
	MakeVolkswagon:   _makeName[59:69],
}

// String implements the Stringer interface.
func (x Make) String() string {
	if str, ok := _makeMap[x]; ok {
		return str
	}
	return fmt.Sprintf("Make(%d)", x)
}

var _makeValue = map[string]Make{
	_makeName[0:6]:                    MakeToyota,
	strings.ToLower(_makeName[0:6]):   MakeToyota,
	_makeName[6:11]:                   MakeChevy,
	strings.ToLower(_makeName[6:11]):  MakeChevy,
	_makeName[11:15]:                  MakeFord,
	strings.ToLower(_makeName[11:15]): MakeFord,
	_makeName[15:20]:                  MakeTesla,
	strings.ToLower(_makeName[15:20]): MakeTesla,
	_makeName[20:27]:                  MakeHyundai,
	strings.ToLower(_makeName[20:27]): MakeHyundai,
	_makeName[27:33]:                  MakeNissan,
	strings.ToLower(_makeName[27:33]): MakeNissan,
	_makeName[33:39]:                  MakeJaguar,
	strings.ToLower(_makeName[33:39]): MakeJaguar,
	_makeName[39:43]:                  MakeAudi,
	strings.ToLower(_makeName[39:43]): MakeAudi,
	_makeName[43:46]:                  MakeBMW,
	strings.ToLower(_makeName[43:46]): MakeBMW,
	_makeName[46:59]:                  MakeMercedesBenz,
	strings.ToLower(_makeName[46:59]): MakeMercedesBenz,
	_makeName[59:69]:                  MakeVolkswagon,
	strings.ToLower(_makeName[59:69]): MakeVolkswagon,
}

// ParseMake attempts to convert a string to a Make.
func ParseMake(name string) (Make, error) {
	if x, ok := _makeValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _makeValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return Make(0), fmt.Errorf("%s is %w", name, ErrInvalidMake)
}

// MarshalText implements the text marshaller method.
func (x Make) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *Make) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseMake(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Set implements the Golang flag.Value interface func.
func (x *Make) Set(val string) error {
	v, err := ParseMake(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *Make) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *Make) Type() string {
	return "Make"
}

const (
	// NoZerosStart is a NoZeros of type Start.
	NoZerosStart NoZeros = iota + 20
	// NoZerosMiddle is a NoZeros of type Middle.
	NoZerosMiddle
	// NoZerosEnd is a NoZeros of type End.
	NoZerosEnd
	// NoZerosPs is a NoZeros of type Ps.
	NoZerosPs
	// NoZerosPps is a NoZeros of type Pps.
	NoZerosPps
	// NoZerosPpps is a NoZeros of type Ppps.
	NoZerosPpps
)

var _noZerosNames = []string{
	_noZerosName[0:5],
	_noZerosName[5:11],
	_noZerosName[11:14],
	_noZerosName[14:16],
	_noZerosName[16:19],
	_noZerosName[19:23],
}

// NoZerosNames returns a list of possible string values of NoZeros.
func NoZerosNames() []string {
	tmp := make([]string, len(_noZerosNames))
	copy(tmp, _noZerosNames)
	return tmp
}

var ErrInvalidNoZeros = fmt.Errorf("not a valid NoZeros, try [%s]", strings.Join(_noZerosNames, ", "))

// NoZerosValues returns a list of the values for NoZeros
func NoZerosValues() []NoZeros {
	return []NoZeros{
		NoZerosStart,
		NoZerosMiddle,
		NoZerosEnd,
		NoZerosPs,
		NoZerosPps,
		NoZerosPpps,
	}
}

const _noZerosName = "startmiddleendpsppsppps"

var _noZerosMap = map[NoZeros]string{
	NoZerosStart:  _noZerosName[0:5],
	NoZerosMiddle: _noZerosName[5:11],
	NoZerosEnd:    _noZerosName[11:14],
	NoZerosPs:     _noZerosName[14:16],
	NoZerosPps:    _noZerosName[16:19],
	NoZerosPpps:   _noZerosName[19:23],
}

// String implements the Stringer interface.
func (x NoZeros) String() string {
	if str, ok := _noZerosMap[x]; ok {
		return str
	}
	return fmt.Sprintf("NoZeros(%d)", x)
}

var _noZerosValue = map[string]NoZeros{
	_noZerosName[0:5]:                    NoZerosStart,
	strings.ToLower(_noZerosName[0:5]):   NoZerosStart,
	_noZerosName[5:11]:                   NoZerosMiddle,
	strings.ToLower(_noZerosName[5:11]):  NoZerosMiddle,
	_noZerosName[11:14]:                  NoZerosEnd,
	strings.ToLower(_noZerosName[11:14]): NoZerosEnd,
	_noZerosName[14:16]:                  NoZerosPs,
	strings.ToLower(_noZerosName[14:16]): NoZerosPs,
	_noZerosName[16:19]:                  NoZerosPps,
	strings.ToLower(_noZerosName[16:19]): NoZerosPps,
	_noZerosName[19:23]:                  NoZerosPpps,
	strings.ToLower(_noZerosName[19:23]): NoZerosPpps,
}

// ParseNoZeros attempts to convert a string to a NoZeros.
func ParseNoZeros(name string) (NoZeros, error) {
	if x, ok := _noZerosValue[name]; ok {
		return x, nil
	}
	// Case insensitive parse, do a separate lookup to prevent unnecessary cost of lowercasing a string if we don't need to.
	if x, ok := _noZerosValue[strings.ToLower(name)]; ok {
		return x, nil
	}
	return NoZeros(0), fmt.Errorf("%s is %w", name, ErrInvalidNoZeros)
}

// MarshalText implements the text marshaller method.
func (x NoZeros) MarshalText() ([]byte, error) {
	return []byte(x.String()), nil
}

// UnmarshalText implements the text unmarshaller method.
func (x *NoZeros) UnmarshalText(text []byte) error {
	name := string(text)
	tmp, err := ParseNoZeros(name)
	if err != nil {
		return err
	}
	*x = tmp
	return nil
}

// Set implements the Golang flag.Value interface func.
func (x *NoZeros) Set(val string) error {
	v, err := ParseNoZeros(val)
	*x = v
	return err
}

// Get implements the Golang flag.Getter interface func.
func (x *NoZeros) Get() interface{} {
	return *x
}

// Type implements the github.com/spf13/pFlag Value interface.
func (x *NoZeros) Type() string {
	return "NoZeros"
}
